// Inside src/index.tsx, update RecordingStage
const RecordingStage: React.FC<RecordingStageProps> = memo(({ stage, isActive, isComplete, isNext, onRecord, onClick, onReRecord }) => {
  const [isRecording, setIsRecording] = useState(false);
  const [isStopping, setIsStopping] = useState(false);
  const [countdown, setCountdown] = useState<number | null>(null);
  const [tempRecording, setTempRecording] = useState<string | null>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const audioChunksRef = useRef<Blob[]>([]);
  const audioRef = useRef<HTMLAudioElement | null>(null);

  useEffect(() => {
    return () => {
      if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {
        mediaRecorderRef.current.stop();
      }
    };
  }, []);

  const startRecording = async () => {
    try {
      console.log('Attempting to start recording for:', stage.label);
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      if (!stream) throw new Error('No audio stream available');
      const possibleTypes = [
        'audio/webm;codecs=opus',
        'audio/webm',
        'audio/mp4',
        'audio/mpeg',
        'audio/ogg;codecs=opus',
      ];
      const mimeType = possibleTypes.find(type => MediaRecorder.isTypeSupported(type)) || 'audio/webm';
      console.log('Using mimeType:', mimeType);
      mediaRecorderRef.current = new MediaRecorder(stream, { mimeType });
      audioChunksRef.current = [];

      mediaRecorderRef.current.ondataavailable = (e) => {
        if (e.data.size > 0) audioChunksRef.current.push(e.data);
      };

      mediaRecorderRef.current.onstop = () => {
        stream.getTracks().forEach(track => track.stop());
        const audioBlob = new Blob(audioChunksRef.current, { type: mimeType });
        const reader = new FileReader();
        reader.onload = () => {
          const audioData = reader.result as string;
          console.log('Recording stopped, data length:', audioData.length);
          setTempRecording(audioData);
          setIsRecording(false);
          setIsStopping(false);
          setCountdown(null);
        };
        reader.readAsDataURL(audioBlob);
      };

      mediaRecorderRef.current.start();
      setIsRecording(true);
    } catch (err) {
      console.error('Recording error:', err);
      alert(`Recording failed: ${err.message}. Please ensure microphone access is granted.`);
      setIsRecording(false);
      setIsStopping(false);
      setCountdown(null);
    }
  };

  const stopRecording = () => {
    if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {
      setIsStopping(true);
      mediaRecorderRef.current.stop();
    }
  };

  const toggleRecording = () => {
    if (isRecording) {
      stopRecording();
    } else {
      setTempRecording(null);
      setCountdown(1);
      setTimeout(startRecording, 1000);
    }
  };

  const playRecording = () => {
    if (tempRecording && audioRef.current) {
      audioRef.current.src = tempRecording;
      audioRef.current.play().catch(err => {
        console.error('Preview playback failed:', err);
        alert('Unable to play preview. Check your device volume or silent mode.');
      });
    }
  };

  const saveRecording = () => {
    if (tempRecording) {
      onRecord(tempRecording);
      setTempRecording(null);
    }
  };

  return (
    <div
      onClick={onClick}
      className={`p-3 rounded-xl cursor-pointer transition-all flex items-center justify-between ${
        isActive
          ? 'bg-blue-100 border-2 border-blue-300'
          : isNext && !isComplete
          ? 'bg-yellow-50 border-2 border-yellow-300'
          : 'bg-gray-100 hover:bg-gray-200'
      }`}
      role="button"
      tabIndex={0}
      aria-label={`Record ${stage.label}`}
      onKeyPress={(e) => e.key === 'Enter' && onClick()}
    >
      <div className="flex items-center gap-2">
        {stage.icon}
        <span className="text-sm font-medium">{stage.label}</span>
      </div>
      <div className="flex items-center gap-2 relative">
        {countdown !== null && (
          <span className="absolute -top-6 text-xs text-blue-600 font-bold">
            Recording in {countdown}...
          </span>
        )}
        {tempRecording ? (
          <div className="flex gap-2">
            <button
              onClick={(e) => {
                e.stopPropagation();
                playRecording();
              }}
              className="p-2 bg-purple-500 rounded-full hover:bg-purple-600 text-white"
              aria-label={`Play preview of ${stage.label}`}
            >
              <Play size={20} aria-hidden="true" />
            </button>
            <button
              onClick={(e) => {
                e.stopPropagation();
                saveRecording();
              }}
              className="p-2 bg-green-500 rounded-full hover:bg-green-600 text-white"
              aria-label={`Save recording for ${stage.label}`}
            >
              <CheckCircle size={20} aria-hidden="true" />
            </button>
            <button
              onClick={(e) => {
                e.stopPropagation();
                onReRecord();
              }}
              className="p-2 bg-blue-500 rounded-full hover:bg-blue-600 text-white"
              aria-label={`Re-record ${stage.label}`}
            >
              <RefreshCw size={20} aria-hidden="true" />
            </button>
            <audio ref={audioRef} className="hidden" />
          </div>
        ) : isComplete ? (
          <>
            <button
              onClick={(e) => {
                e.stopPropagation();
                onReRecord();
              }}
              className="p-2 bg-blue-500 rounded-full hover:bg-blue-600 text-white"
              aria-label={`Re-record ${stage.label}`}
            >
              <RefreshCw size={20} aria-hidden="true" />
            </button>
            <CheckCircle size={20} className="text-green-500" aria-hidden="true" />
          </>
        ) : isActive && isRecording ? (
          <button
            onClick={(e) => {
              e.stopPropagation();
              toggleRecording();
            }}
            className={`p-2 rounded-full ${isStopping ? 'bg-gray-400' : 'bg-red-500 hover:bg-red-600'} text-white`}
            aria-label={isStopping ? 'Stopping recording' : 'Stop recording'}
            disabled={isStopping}
          >
            {isStopping ? <Loader2 size={20} className="animate-spin" aria-hidden="true" /> : <Square size={20} aria-hidden="true" />}
          </button>
        ) : isActive ? (
          <button
            onClick={(e) => {
              e.stopPropagation();
              toggleRecording();
            }}
            className="p-2 bg-orange-500 rounded-full hover:bg-orange-600 text-white"
            aria-label="Start recording"
            disabled={countdown !== null}
          >
            <Mic size={20} aria-hidden="true" />
          </button>
        ) : null}
      </div>
    </div>
  );
});

// Inside RecordingScreen, update the onReRecord handler
const RecordingScreen: React.FC<RecordingScreenProps> = memo(({ name, recordings, setRecordings, onComplete, onBack }) => {
  const [currentStage, setCurrentStage] = useState(0);
  const letters = name.split('');

  const stages: Stage[] = [
    { 
      id: 'fullname', 
      label: `Full Name: "${name}"`, 
      key: 'fullname',
      instruction: `Say their name clearly: "${name}"`,
      icon: <Volume2 size={20} />
    },
    ...letters.map((letter, i) => ({
      id: `letter-${i}`,
      label: `Letter ${i + 1}: "${letter}"`,
      key: `letter-${i}`,
      instruction: `Say the SOUND of "${letter}" (not the letter name)\nExample: B = "buh" not "bee"`,
      icon: <BookOpen size={20} />
    })),
    { 
      id: 'sentence', 
      label: 'Walking Sentence', 
      key: 'sentence',
      instruction: `Say: "${name}, do you want to go for a walk?"`,
      icon: <Moon size={20} />
    },
    { 
      id: 'rhyme', 
      label: `Fun Rhyme`, 
      key: 'rhyme',
      instruction: `Make a fun rhyme with "${name}"\nExample: "${name} is sweet, from head to feet!"`,
      icon: <Music size={20} />
    }
  ];

  const isComplete = stages.every(stage => recordings[stage.key]);
  const nextUnrecordedStage = stages.findIndex(stage => !recordings[stage.key]);

  const startRecordingForStage = async (stageIndex: number) => {
    setCurrentStage(stageIndex);
    const stage = stages[stageIndex];
    try {
      console.log('Starting recording for stage:', stage.label);
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      if (!stream) throw new Error('No audio stream available');
      const possibleTypes = [
        'audio/webm;codecs=opus',
        'audio/webm',
        'audio/mp4',
        'audio/mpeg',
        'audio/ogg;codecs=opus',
      ];
      const mimeType = possibleTypes.find(type => MediaRecorder.isTypeSupported(type)) || 'audio/webm';
      const mediaRecorder = new MediaRecorder(stream, { mimeType });
      const audioChunks: Blob[] = [];

      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) audioChunks.push(e.data);
      };

      mediaRecorder.onstop = () => {
        stream.getTracks().forEach(track => track.stop());
        const audioBlob = new Blob(audioChunks, { type: mimeType });
        const reader = new FileReader();
        reader.onload = () => {
          const audioData = reader.result as string;
          console.log('Recording stopped for:', stage.label, 'data length:', audioData.length);
          setRecordings(prev => ({
            ...prev,
            [stage.key]: audioData
          }));
        };
        reader.readAsDataURL(audioBlob);
      };

      setTimeout(() => {
        mediaRecorder.start();
      }, 1000);
    } catch (err) {
      console.error('Recording error for stage:', stage.label, err);
      alert(`Recording failed for ${stage.label}: ${err.message}. Please ensure microphone access is granted.`);
    }
  };

  const handleBack = () => {
    if (window.confirm('Going back will clear all recordings and the name. Are you sure?')) {
      onBack();
    }
  };

  return (
    <div className="min-h-screen p-4 flex items-center justify-center">
      <div className="bg-white rounded-2xl p-6 max-w-lg w-full shadow-2xl relative">
        <div className="relative">
          <button
            onClick={handleBack}
            className="absolute top-4 left-4 p-2 text-gray-600 hover:bg-gray-100 rounded-full"
            aria-label="Go back to name entry and clear recordings"
            id="back-button"
          >
            <ArrowLeft size={20} aria-hidden="true" />
          </button>
        </div>

        <h2 className="text-2xl font-bold text-gray-800 mb-6 text-center">
          Record Your Voice for {name}
        </h2>

        {Object.keys(recordings).length > 0 && Object.keys(recordings).length < stages.length && (
          <div className="bg-purple-50 border border-purple-200 p-2 rounded-lg mb-3 text-center">
            <p className="text-xs text-purple-700">
              üíú Even partial recordings help! You can always add more later.
            </p>
          </div>
        )}

        <div className="bg-blue-50 border border-blue-200 p-3 rounded-lg mb-4">
          <div className="flex items-center gap-2 text-blue-800">
            <Info size={16} aria-hidden="true" />
            <p className="text-sm font-medium">How to Record:</p>
          </div>
          <ol className="text-sm text-blue-700 mt-1 ml-6 list-decimal">
            <li>Tap any item to select it</li>
            <li>Tap the RED microphone to START recording</li>
            <li>Say the word/sound clearly</li>
            <li>Tap the SQUARE to STOP</li>
            <li>Preview with PLAY, then SAVE or RE-RECORD</li>
            <li><strong>To re-record: Tap the BLUE refresh icon</strong></li>
          </ol>
        </div>

        <div className="mb-4">
          <div className="flex justify-between items-center mb-2">
            <span className="text-sm text-gray-600 font-medium">Your Progress</span>
            <span className="text-sm text-gray-600 font-medium">
              {Object.keys(recordings).length} of {stages.length} done
            </span>
          </div>
          <div className="h-3 bg-gray-200 rounded-full overflow-hidden">
            <div
              className="h-full bg-gradient-to-r from-purple-500 to-pink-500 transition-all duration-500"
              style={{ width: `${(Object.keys(recordings).length / stages.length) * 100}%` }}
            />
          </div>
          {Object.keys(recordings).length > 0 && (
            <p className="text-xs text-gray-500 mt-1 text-center">
              Storage used: ~{((JSON.stringify(recordings).length / 1024 / 1024) * 2).toFixed(1)}MB
            </p>
          )}
        </div>

        <div className="space-y-2 mb-6 max-h-80 overflow-y-auto">
          {stages.map((stage, index) => (
            <div key={stage.id} className="relative">
              <RecordingStage
                stage={stage}
                isActive={index === currentStage}
                isComplete={!!recordings[stage.key]}
                isNext={index === nextUnrecordedStage}
                onRecord={(audioData: string) => {
                  setRecordings(prev => ({
                    ...prev,
                    [stage.key]: audioData
                  }));
                  if (index < stages.length - 1) {
                    setTimeout(() => setCurrentStage(index + 1), 1000);
                  }
                }}
                onClick={() => setCurrentStage(index)}
                onReRecord={() => {
                  console.log('Re-recording initiated for:', stage.label);
                  setRecordings(prev => {
                    const newRecordings = { ...prev };
                    delete newRecordings[stage.key]; // Clear the existing recording
                    startRecordingForStage(index).then(() => {
                      console.log('Re-recording started for:', stage.label);
                    }).catch(err => {
                      console.error('Re-recording failed:', err);
                    });
                    return newRecordings;
                  });
                }}
              />
            </div>
          ))}
        </div>

        <button
          onClick={onComplete}
          disabled={!isComplete}
          className={`w-full py-4 rounded-xl font-bold text-xl transition-all ${
            isComplete
              ? 'bg-gradient-to-r from-green-500 to-green-600 text-white hover:from-green-600 hover:to-green-700'
              : 'bg-gray-300 text-gray-500'
          }`}
          aria-label={isComplete ? "Create flashcards" : "Complete all recordings to proceed"}
        >
          {isComplete ? 'üéâ All Done! Create Flashcards' : `üìù ${stages.length - Object.keys(recordings).length} recordings left`}
        </button>

        {isComplete && (
          <p className="text-xs text-gray-500 text-center mt-2">
            üí° Tip: Test audio playback in flashcards. If no sound, check volume/silent mode.
          </p>
        )}
      </div>
    </div>
  );
});