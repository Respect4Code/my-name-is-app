It’s **04:34 PM BST on Sunday, August 17, 2025**, and I’ve reviewed your request to add a new "Secret Sauce" page for Action mode (similar to the Standard mode page), with a focus on sentence-building and playback enhancements. Let’s address your ideas for the pink and green buttons in Action mode and clarify the "Start Again" or "Over" button behavior on the Standard page.

---

### Proposed New Page for Action Mode
Adding a "Secret Sauce" page for Action mode makes sense to extend the recording experience. This page would:
- **Pink Button Flow**: After typing "climbing" with the pink button, allow users to build a sentence (e.g., "Sam climbing," "We are climbing," "Mummy is climbing") and record/play it back.
- **Green Button Flow**: After recording all category words with the green button, provide a playback option for the sequence, with an optional sentence (e.g., "I am eating, then going climbing and jumping") for added context.

#### Thoughts on Your Suggestions
- **Sentence with Pink Button**: Adding sentences is a great way to make the app more engaging and educational, especially for toddlers. Recording and playback will reinforce learning.
- **Green Button Playback**: A playback button for the full category sequence is practical. The optional sentence idea (e.g., your random "I am eating, then going climbing and jumping") adds creativity and could work if tied to a category narrative (e.g., daily routine). It’s useful but optional—users can skip it if desired.
- **Category Flexibility**: Your example mixes categories (daily: "eating," movement: "climbing, jumping"), which is fine for flexibility. We could limit it to one category or allow mixes—your preference based on app goals.

---

### Solution: New Action Mode Page
Here’s an updated `client/src/App.tsx` adding the "Secret Sauce" page for Action mode. This includes sentence-building for the pink button and playback for the green button.

```javascript
import React, { useState, useCallback, useRef, useEffect, memo } from 'react';

const WelcomeScreen: React.FC<{ onNext: () => void; onGuide: () => void }> = memo(({ onNext, onGuide }) => {
  const [name, setName] = useState('');
  const [infoPressing, setInfoPressing] = useState(false);
  const [infoPressTimer, setInfoPressTimer] = useState<NodeJS.Timeout | null>(null);
  const [showSecretMenu, setShowSecretMenu] = useState(false);
  const [currentMode, setCurrentMode] = useState<'standard' | 'alphabet' | 'numbers' | 'actions' | 'grandparent' | 'vip'>(
    (sessionStorage.getItem('mode') as any) || 'standard'
  );
  const [showToast, setShowToast] = useState(false);
  const [toastMessage, setToastMessage] = useState('');
  const [isLongPress, setIsLongPress] = useState(false);
  const [ingView, setIngView] = useState<'grid' | 'words' | 'record' | 'sentence'>('grid');
  const [ingCategory, setIngCategory] = useState<keyof typeof ING | null>(null);
  const [ingQueue, setIngQueue] = useState<string[]>([]);
  const [ingIndex, setIngIndex] = useState(0);
  const [recordedAudio, setRecordedAudio] = useState<Blob[]>([]);
  const [sentence, setSentence] = useState('');
  const recorderRef = useRef<MediaRecorder | null>(null);

  // Toast notification
  const showToastNotification = useCallback((message: string) => {
    setToastMessage(message);
    setShowToast(true);
    setTimeout(() => setShowToast(false), 3000);
  }, []);

  // Info button handlers
  const handleInfoMouseDown = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    setIsLongPress(false);
    setInfoPressing(true);
    const timer = setTimeout(() => {
      setIsLongPress(true);
      setShowSecretMenu(true);
      setInfoPressing(false);
      showToastNotification('🎯 Secret menu activated!');
    }, 600);
    setInfoPressTimer(timer);
  }, [showToastNotification]);

  const handleInfoMouseUp = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    setInfoPressing(false);
    if (infoPressTimer) {
      clearTimeout(infoPressTimer);
      setInfoPressTimer(null);
    }
    if (!isLongPress && !showSecretMenu) {
      onGuide();
    }
    setIsLongPress(false);
  }, [infoPressTimer, isLongPress, showSecretMenu, onGuide]);

  const handlePointerLeave = useCallback(() => {
    if (infoPressTimer) {
      clearTimeout(infoPressTimer);
      setInfoPressTimer(null);
      setInfoPressing(false);
      setIsLongPress(false);
    }
  }, [infoPressTimer]);

  const handleInfoTouchStart = useCallback((e: React.TouchEvent) => {
    e.preventDefault();
    handleInfoMouseDown(e as any);
  }, [handleInfoMouseDown]);

  const handleInfoTouchEnd = useCallback((e: React.TouchEvent) => {
    e.preventDefault();
    handleInfoMouseUp(e as any);
  }, [handleInfoMouseUp]);

  // Mode selection
  const setMode = useCallback((mode: typeof currentMode) => {
    setCurrentMode(mode);
    setShowSecretMenu(false);
    if (mode === 'vip') {
      sessionStorage.clear();
      localStorage.clear();
    } else {
      sessionStorage.setItem('mode', mode);
    }
    const messages = {
      standard: '🏠 Standard Mode Active - Enter a name to begin',
      actions: '🎬 Action Words Mode Active - Choose a category',
      alphabet: '🔤 Alphabet Mode Active - Enter letters to begin',
      numbers: '🔢 Numbers Mode Active - Enter numbers to begin',
      grandparent: '👴 Grandparent Mode Active - Larger text enabled',
      vip: '🔒 VIP Mode Active - Maximum privacy enabled',
    };
    showToastNotification(messages[mode]);
    if (mode === 'actions') {
      setIngView('grid');
      setIngCategory(null);
      if (recorderRef.current?.state === 'recording') {
        recorderRef.current.stop();
      }
      setIngQueue([]);
      setIngIndex(0);
      setRecordedAudio([]);
      setSentence('');
    }
    setIsLongPress(false);
  }, [showToastNotification]);

  // Proceed next
  const proceedNext = useCallback(() => {
    const value = name.trim();
    const isValidIngWord = value.length > 0 && /ing$/i.test(value);
    if (!value && currentMode !== 'actions') {
      alert('Please enter a name or word first');
      return;
    }
    if (currentMode === 'actions') {
      if (ingView === 'grid' && !isValidIngWord) {
        setIngView('grid');
      } else if (isValidIngWord) {
        chooseWord(value);
      } else if (ingView === 'words' && !ingQueue.length) {
        alert('Please select a word or type one to record');
      } else if (ingView === 'record') {
        const nextIndex = ingIndex + 1;
        if (nextIndex < ingQueue.length) {
          setIngIndex(nextIndex);
          setIngView('record');
        } else {
          setIngView('sentence');
        }
      } else if (ingView === 'sentence') {
        onNext(); // Proceed to next mode or reset
      }
    } else {
      onNext();
    }
  }, [currentMode, name, ingView, ingQueue.length, ingIndex, onNext]);

  // Action Words data
  const ING = {
    daily: ['eating', 'drinking', 'brushing', 'washing', 'sleeping', 'waking'],
    movement: ['running', 'jumping', 'walking', 'crawling', 'rolling', 'spinning'],
    hands: ['clapping', 'waving', 'grabbing', 'throwing', 'catching', 'pointing'],
    emotions: ['laughing', 'smiling', 'crying', 'hugging', 'kissing', 'loving'],
    creative: ['drawing', 'painting', 'singing', 'dancing', 'building', 'making'],
    playing: ['hiding', 'seeking', 'climbing', 'sliding', 'swinging', 'bouncing'],
  };

  // Navigation functions
  const openCategory = useCallback((cat: keyof typeof ING) => {
    setIngCategory(cat);
    setIngView('words');
  }, []);

  const chooseWord = useCallback((word: string) => {
    setIngQueue([word.toLowerCase()]);
    setIngIndex(0);
    setIngView('record');
  }, []);

  const chooseAllInCategory = useCallback(() => {
    if (!ingCategory) return;
    const words = ING[ingCategory];
    setIngQueue(words);
    setIngIndex(0);
    setIngView('record');
  }, [ingCategory]);

  // Magic words detection
  useEffect(() => {
    const value = name.trim().toUpperCase();
    if (value === 'ING' || value === 'ACTIONS') {
      setMode('actions');
      setName('');
    } else if (value === 'ALPHABET' || value === 'ABC') {
      setMode('alphabet');
      setName('');
    } else if (value === 'NUMBERS' || value === '123') {
      setMode('numbers');
      setName('');
    } else if (value === 'GRANDPA' || value === 'GRANDPARENT') {
      setMode('grandparent');
      setName('');
    } else if (value === 'VIP') {
      setMode('vip');
      setName('');
    }
  }, [name, setMode]);

  // Mode-specific styling
  const getModeStyle = () => {
    switch (currentMode) {
      case 'actions': return { background: 'linear-gradient(135deg, #fff0ff, #ffe0ff)' };
      case 'alphabet': return { background: 'linear-gradient(135deg, #e0f0ff, #d0e8ff)' };
      case 'numbers': return { background: 'linear-gradient(135deg, #e0ffe0, #d0ffd0)' };
      case 'grandparent': return { background: 'linear-gradient(135deg, #fff8e0, #fff0d0)', fontSize: '18px' };
      case 'vip': return { background: 'linear-gradient(135deg, #fffde0, #fff8d0)' };
      default: return { background: 'white' };
    }
  };

  // Pretty print category
  const pretty = (cat: string) => cat.charAt(0).toUpperCase() + cat.slice(1);

  return (
    <div className="app-wrapper" style={{ minHeight: '100vh', padding: '20px' }}>
      {/* Mode Banner */}
      {currentMode !== 'standard' && (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          padding: '12px',
          background: currentMode === 'actions' ? '#ff00ff' :
                     currentMode === 'alphabet' ? '#007bff' :
                     currentMode === 'numbers' ? '#00cc00' :
                     currentMode === 'grandparent' ? '#ff8800' :
                     currentMode === 'vip' ? '#ffcc00' : '#333',
          color: 'white',
          textAlign: 'center',
          fontSize: '16px',
          fontWeight: 'bold',
          zIndex: 1000,
          boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
        }}>
          {currentMode === 'actions' && '🎬 ACTION WORDS MODE ACTIVE'}
          {currentMode === 'alphabet' && '🔤 ALPHABET MODE ACTIVE'}
          {currentMode === 'numbers' && '🔢 NUMBERS MODE ACTIVE'}
          {currentMode === 'grandparent' && '👴 GRANDPARENT MODE ACTIVE'}
          {currentMode === 'vip' && '🔒 VIP MODE - MAXIMUM SECURITY'}
        </div>
      )}

      <div className="app-container" style={{
        ...getModeStyle(),
        borderRadius: '24px',
        padding: currentMode !== 'standard' ? '60px 30px 30px' : '40px 30px',
        maxWidth: '480px',
        margin: '0 auto',
        boxShadow: '0 20px 60px rgba(0,0,0,0.1)',
        position: 'relative',
        transition: 'all 0.3s ease',
      }}>
        {/* Info Button */}
        <button
          className={`info-btn ${infoPressing ? 'pressing' : ''}`}
          style={{
            position: 'absolute',
            top: '20px',
            right: '20px',
            background: infoPressing ? '#ddd' : 'transparent',
            border: '2px solid #666',
            borderRadius: '50%',
            width: '40px',
            height: '40px',
            fontSize: '20px',
            cursor: 'pointer',
            transition: 'all 0.2s',
          }}
          onMouseDown={handleInfoMouseDown}
          onMouseUp={handleInfoMouseUp}
          onMouseLeave={handlePointerLeave}
          onTouchStart={handleInfoTouchStart}
          onTouchEnd={handleInfoTouchEnd}
          onTouchCancel={handlePointerLeave}
          aria-label="Information"
        >
          ℹ️
        </button>

        {/* Secret Menu Dropdown */}
        {showSecretMenu && (
          <div className="dropdown-menu" style={{
            position: 'absolute',
            top: '70px',
            right: '20px',
            background: 'white',
            border: '2px solid #333',
            borderRadius: '10px',
            padding: '10px',
            zIndex: 1001,
            minWidth: '250px',
            boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
          }}>
            <div style={{ fontSize: '12px', color: '#666', marginBottom: '10px' }}>
              SECRET FEATURES
            </div>
            {['standard', 'actions', 'alphabet', 'numbers', 'grandparent', 'vip'].map((mode) => (
              <button
                key={mode}
                onClick={(e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  setMode(mode as any);
                }}
                style={{
                  display: 'block',
                  width: '100%',
                  padding: '10px',
                  margin: '5px 0',
                  background: currentMode === mode ? '#4CAF50' : '#f0f0f0',
                  color: currentMode === mode ? 'white' : 'black',
                  border: 'none',
                  borderRadius: '5px',
                  cursor: 'pointer',
                  textAlign: 'left',
                  transition: 'all 0.2s',
                }}
              >
                {mode === 'standard' && '🏠 Standard Mode'}
                {mode === 'actions' && '🎬 Action Words Mode'}
                {mode === 'alphabet' && '🔤 Alphabet Mode'}
                {mode === 'numbers' && '🔢 Numbers Mode'}
                {mode === 'grandparent' && '👴 Grandparent Mode'}
                {mode === 'vip' && '🔒 VIP Mode'}
                {currentMode === mode && ' ✓'}
              </button>
            ))}
          </div>
        )}

        {/* Main Content */}
        {currentMode === 'actions' ? (
          <>
            {ingView === 'grid' && (
              <div>
                <h2 style={{ textAlign: 'center', marginBottom: '20px' }}>
                  🎬 Choose a Category
                </h2>
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '15px' }}>
                  {Object.keys(ING).map((cat) => (
                    <button
                      key={cat}
                      onClick={() => openCategory(cat as keyof typeof ING)}
                      style={{
                        padding: '20px',
                        background: 'white',
                        border: '2px solid #ff00ff',
                        borderRadius: '10px',
                        cursor: 'pointer',
                        transition: 'all 0.2s',
                        textAlign: 'center',
                      }}
                      onMouseEnter={(e) => {
                        e.currentTarget.style.background = '#ff00ff';
                        e.currentTarget.style.color = 'white';
                      }}
                      onMouseLeave={(e) => {
                        e.currentTarget.style.background = 'white';
                        e.currentTarget.style.color = 'black';
                      }}
                    >
                      <div style={{ fontSize: '30px', marginBottom: '10px' }}>
                        {cat === 'daily' ? '🍽️' : cat === 'movement' ? '🏃' : cat === 'hands' ? '✋' :
                         cat === 'emotions' ? '😊' : cat === 'creative' ? '🎨' : '🎮'}
                      </div>
                      <div style={{ fontWeight: 'bold', marginBottom: '5px' }}>
                        {pretty(cat)}
                      </div>
                      <div style={{ fontSize: '12px', opacity: '0.7' }}>
                        {ING[cat as keyof typeof ING].slice(0, 3).join(', ')}...
                      </div>
                    </button>
                  ))}
                </div>
              </div>
            )}

            {ingView === 'words' && ingCategory && (
              <div>
                <button
                  onClick={() => setIngView('grid')}
                  style={{
                    background: 'transparent',
                    border: 'none',
                    fontSize: '24px',
                    cursor: 'pointer',
                    marginBottom: '20px',
                  }}
                >
                  ← Back
                </button>
                <h3 style={{ textAlign: 'center', marginBottom: '20px' }}>
                  {pretty(ingCategory)} Actions
                </h3>
                <div className="chip-grid" style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(80px, 1fr))', gap: '10px', marginBottom: '20px' }}>
                  {ING[ingCategory].map((w) => (
                    <button
                      key={w}
                      className="chip"
                      onClick={() => chooseWord(w)}
                      style={{
                        padding: '10px',
                        background: '#f0f0f0',
                        border: '1px solid #ddd',
                        borderRadius: '15px',
                        cursor: 'pointer',
                        transition: 'all 0.2s',
                      }}
                      onMouseEnter={(e) => {
                        e.currentTarget.style.background = '#ff00ff';
                        e.currentTarget.style.color = 'white';
                      }}
                      onMouseLeave={(e) => {
                        e.currentTarget.style.background = '#f0f0f0';
                        e.currentTarget.style.color = 'black';
                      }}
                    >
                      {w}
                    </button>
                  ))}
                </div>
                <div style={{ textAlign: 'center', marginBottom: '10px', color: '#666' }}>or</div>
                <input
                  placeholder="Type your own -ING word(s) (e.g., climbing, waving)"
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' && e.currentTarget.value.trim()) {
                      const words = e.currentTarget.value.trim().split(',').map(w => w.trim().toLowerCase()).filter(w => /ing$/i.test(w));
                      if (words.length) {
                        setIngQueue(words);
                        setIngIndex(0);
                        setIngView('record');
                      }
                    }
                  }}
                  style={{
                    width: '100%',
                    padding: '10px',
                    border: '2px solid #ddd',
                    borderRadius: '10px',
                    marginBottom: '10px',
                    boxSizing: 'border-box',
                  }}
                />
                <div style={{ display: 'flex', gap: '10px', justifyContent: 'center' }}>
                  <button
                    onClick={() => {
                      const v = document.querySelector<HTMLInputElement>('input')?.value?.trim();
                      if (v) {
                        const words = v.split(',').map(w => w.trim().toLowerCase()).filter(w => /ing$/i.test(w));
                        if (words.length) {
                          setIngQueue(words);
                          setIngIndex(0);
                          setIngView('record');
                        }
                      }
                    }}
                    style={{
                      padding: '10px 15px',
                      background: '#ff00ff',
                      color: 'white',
                      border: 'none',
                      borderRadius: '10px',
                      cursor: 'pointer',
                      fontWeight: 'bold',
                    }}
                  >
                    Record Typed Word(s) →
                  </button>
                  <button
                    onClick={chooseAllInCategory}
                    style={{
                      padding: '10px 15px',
                      background: '#4CAF50',
                      color: 'white',
                      border: 'none',
                      borderRadius: '10px',
                      cursor: 'pointer',
                      fontWeight: 'bold',
                    }}
                  >
                    Record All in Category →
                  </button>
                </div>
              </div>
            )}

            {ingView === 'record' && ingQueue.length > 0 && (
              <RecordWord
                word={ingQueue[ingIndex]}
                onNext={() => {
                  const next = ingIndex + 1;
                  if (next < ingQueue.length) {
                    setIngIndex(next);
                    setIngView('record');
                  } else {
                    setIngView('sentence');
                  }
                }}
                onBack={() => setIngView('words')}
                onRecord={(blob) => setRecordedAudio((prev) => [...prev, blob])}
              />
            )}

            {ingView === 'sentence' && (
              <SentencePage
                words={ingQueue}
                recordedAudio={recordedAudio}
                sentence={sentence}
                setSentence={setSentence}
                onBack={() => setIngView(ingQueue.length > 1 ? 'words' : 'record')}
                onNext={proceedNext}
              />
            )}
          </>
        ) : (
          <>
            <div className="logo" style={{ textAlign: 'center', marginBottom: '20px' }}>
              <span style={{
                background: 'linear-gradient(45deg, #ff00ff, #00ffff)',
                color: 'white',
                padding: '10px 20px',
                borderRadius: '20px',
                fontWeight: 'bold',
              }}>BoredMama</span>
            </div>
            <h1 style={{ textAlign: 'center', fontSize: '32px', margin: '20px 0' }}>
              My Name Is
            </h1>
            <p style={{ textAlign: 'center', color: '#666', marginBottom: '20px' }}>
              {currentMode === 'standard' && 'Teach your child their name with YOUR voice'}
              {currentMode === 'actions' && 'Teach action words with YOUR voice (-ING verbs)'}
              {currentMode === 'alphabet' && 'Teach the alphabet with YOUR voice'}
              {currentMode === 'numbers' && 'Teach numbers with YOUR voice'}
              {currentMode === 'grandparent' && 'Easy mode with larger text'}
              {currentMode === 'vip' && 'Maximum privacy - no data stored'}
            </p>
            <div style={{ textAlign: 'center', marginBottom: '20px' }}>
              <span className="star">⭐</span>
              <span>
                {currentMode === 'standard' && '"My 18-month-old learned all letters phonetically!" - Real parent'}
                {currentMode === 'actions' && '"My toddler loves recording -ING verbs!" - Happy parent'}
                {currentMode === 'alphabet' && '"Great for letter sounds!" - Parent'}
                {currentMode === 'numbers' && '"Counting made fun!" - Parent'}
                {currentMode === 'grandparent' && '"Easy for grandparents to use!" - Family'}
                {currentMode === 'vip' && '"Perfect privacy for my child!" - Parent'}
              </span>
            </div>
            <input
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === 'Enter' && currentMode === 'actions' && name.trim().length > 0 && /ing$/i.test(name)) {
                  chooseWord(name.trim());
                }
              }}
              placeholder={
                currentMode === 'standard' ? "Enter your child's name" :
                currentMode === 'actions' ? "Type an -ING word or category (e.g., climbing)" :
                currentMode === 'alphabet' ? "Enter letters (A-Z)" :
                currentMode === 'numbers' ? "Enter numbers (0-9)" :
                currentMode === 'grandparent' ? "TYPE THE CHILD'S NAME" :
                currentMode === 'vip' ? "Enter name (Privacy Mode)" :
                "Enter a value"
              }
              style={{
                width: '100%',
                padding: currentMode === 'grandparent' ? '20px' : '15px',
                fontSize: currentMode === 'grandparent' ? '24px' : '18px',
                border: '2px solid #ddd',
                borderRadius: '10px',
                marginBottom: '20px',
                boxSizing: 'border-box',
              }}
              autoComplete="off"
            />
            <button
              onClick={proceedNext}
              style={{
                width: currentMode === 'actions' ? 'auto' : '100%',
                padding: currentMode === 'grandparent' ? '20px' : '15px',
                fontSize: currentMode === 'grandparent' ? '24px' : '18px',
                background: currentMode === 'actions' && name.trim().length > 0 && /ing$/i.test(name) ? '#ff00ff' : '#4CAF50',
                color: 'white',
                border: 'none',
                borderRadius: '10px',
                cursor: 'pointer',
                margin: currentMode === 'actions' ? '0 auto' : '0',
                display: 'block',
              }}
              disabled={currentMode === 'actions' && name.trim().length > 0 && !/ing$/i.test(name)}
            >
              {currentMode === 'actions' && name.trim().length > 0 && /ing$/i.test(name) ? 'Start Recording →' :
               currentMode === 'actions' ? 'Show Categories →' : 'Next →'}
            </button>
            {currentMode === 'standard' && (
              <button
                onClick={() => {
                  setName('');
                  setIngView('grid'); // Reset to category page for consistency
                }}
                style={{
                  width: '100%',
                  padding: '10px',
                  background: '#ff4444',
                  color: 'white',
                  border: 'none',
                  borderRadius: '10px',
                  cursor: 'pointer',
                  marginTop: '10px',
                }}
              >
                Start Again
              </button>
            )}
          </>
        )}
      </div>

      {/* Toast Notification */}
      {showToast && (
        <div style={{
          position: 'fixed',
          bottom: '20px',
          left: '50%',
          transform: 'translateX(-50%)',
          background: '#333',
          color: 'white',
          padding: '15px 30px',
          borderRadius: '30px',
          zIndex: 1002,
          animation: 'fadeIn 0.3s ease',
        }}>
          {toastMessage}
        </div>
      )}
    </div>
  );
}, (prevProps, nextProps) => prevProps.onNext === nextProps.onNext && prevProps.onGuide === nextProps.onGuide);

// RecordWord component
const RecordWord: React.FC<{ word: string; onNext: () => void; onBack: () => void; onRecord: (blob: Blob) => void }> = ({ word, onNext, onBack, onRecord }) => {
  const [rec, setRec] = useState<MediaRecorder | null>(null);
  const [audioURL, setAudioURL] = useState<string>('');
  const chunksRef = useRef<Blob[]>([]);

  async function start() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' :
                   MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4' : '';
      const r = new MediaRecorder(stream, mime ? { mimeType: mime } : undefined);
      chunksRef.current = [];
      r.ondataavailable = (e) => e.data.size && chunksRef.current.push(e.data);
      r.onstop = () => {
        const blob = new Blob(chunksRef.current, { type: mime || 'audio/webm' });
        setAudioURL(URL.createObjectURL(blob));
        onRecord(blob);
        stream.getTracks().forEach((t) => t.stop());
      };
      r.start();
      setRec(r);
      setTimeout(() => r.state === 'recording' && r.stop(), 15000); // 15s max
    } catch (err) {
      alert('Microphone access denied. Please allow permission.');
    }
  }

  function stop() {
    rec?.stop();
    setRec(null);
  }

  useEffect(() => {
    return () => {
      if (rec?.state === 'recording') rec.stop();
    };
  }, [rec]);

  return (
    <div>
      <button
        onClick={onBack}
        style={{
          background: 'transparent',
          border: 'none',
          fontSize: '24px',
          cursor: 'pointer',
          marginBottom: '20px',
        }}
      >
        ← Back
      </button>
      <h2 style={{ textAlign: 'center', marginBottom: '20px' }}>Recording: {word}</h2>
      <p style={{ textAlign: 'center', marginBottom: '20px', color: '#666' }}>
        Say the word, then a short sentence, e.g., “We are {word}!”
      </p>
      {!rec && (
        <button
          className="record"
          onClick={start}
          style={{
            width: '100%',
            padding: '15px',
            background: '#ff00ff',
            color: 'white',
            border: 'none',
            borderRadius: '10px',
            cursor: 'pointer',
            fontWeight: 'bold',
          }}
        >
          🎤 Record (15s max)
        </button>
      )}
      {rec && (
        <button
          className="stop"
          onClick={stop}
          style={{
            width: '100%',
            padding: '15px',
            background: '#ff4444',
            color: 'white',
            border: 'none',
            borderRadius: '10px',
            cursor: 'pointer',
            fontWeight: 'bold',
          }}
        >
          ■ Stop
        </button>
      )}
      {audioURL && (
        <div style={{ textAlign: 'center', marginTop: '20px' }}>
          <audio src={audioURL} controls style={{ width: '100%', marginBottom: '10px' }} />
          <button
            onClick={onNext}
            style={{
              width: '100%',
              padding: '15px',
              background: '#4CAF50',
              color: 'white',
              border: 'none',
              borderRadius: '10px',
              cursor: 'pointer',
              fontWeight: 'bold',
            }}
          >
            Next →
          </button>
        </div>
      )}
    </div>
  );
};

// SentencePage component
const SentencePage: React.FC<{
  words: string[];
  recordedAudio: Blob[];
  sentence: string;
  setSentence: (s: string) => void;
  onBack: () => void;
  onNext: () => void;
}> = ({ words, recordedAudio, sentence, setSentence, onBack, onNext }) => {
  const [rec, setRec] = useState<MediaRecorder | null>(null);
  const [audioURL, setAudioURL] = useState<string>('');
  const chunksRef = useRef<Blob[]>([]);

  async function start() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' :
                   MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4' : '';
      const r = new MediaRecorder(stream, mime ? { mimeType: mime } : undefined);
      chunksRef.current = [];
      r.ondataavailable = (e) => e.data.size && chunksRef.current.push(e.data);
      r.onstop = () => {
        const blob = new Blob(chunksRef.current, { type: mime || 'audio/webm' });
        setAudioURL(URL.createObjectURL(blob));
        stream.getTracks().forEach((t) => t.stop());
      };
      r.start();
      setRec(r);
      setTimeout(() => r.state === 'recording' && r.stop(), 15000); // 15s max
    } catch (err) {
      alert('Microphone access denied. Please allow permission.');
    }
  }

  function stop() {
    rec?.stop();
    setRec(null);
  }

  useEffect(() => {
    return () => {
      if (rec?.state === 'recording') rec.stop();
    };
  }, [rec]);

  return (
    <div>
      <button
        onClick={onBack}
        style={{
          background: 'transparent',
          border: 'none',
          fontSize: '24px',
          cursor: 'pointer',
          marginBottom: '20px',
        }}
      >
        ← Back
      </button>
      {words.length === 1 ? (
        <>
          <h2 style={{ textAlign: 'center', marginBottom: '20px' }}>Add a Sentence</h2>
          <p style={{ textAlign: 'center', marginBottom: '20px', color: '#666' }}>
            E.g., “{words[0]}” or “We are {words[0]}!”
          </p>
          <input
            value={sentence}
            onChange={(e) => setSentence(e.target.value)}
            placeholder={`Add a sentence with ${words[0]} (e.g., Sam ${words[0]})`}
            style={{
              width: '100%',
              padding: '10px',
              border: '2px solid #ddd',
              borderRadius: '10px',
              marginBottom: '10px',
              boxSizing: 'border-box',
            }}
          />
          {!rec && (
            <button
              onClick={start}
              style={{
                width: '100%',
                padding: '15px',
                background: '#ff00ff',
                color: 'white',
                border: 'none',
                borderRadius: '10px',
                cursor: 'pointer',
                fontWeight: 'bold',
              }}
            >
              🎤 Record Sentence (15s max)
            </button>
          )}
          {rec && (
            <button
              onClick={stop}
              style={{
                width: '100%',
                padding: '15px',
                background: '#ff4444',
                color: 'white',
                border: 'none',
                borderRadius: '10px',
                cursor: 'pointer',
                fontWeight: 'bold',
              }}
            >
              ■ Stop
            </button>
          )}
          {audioURL && (
            <div style={{ textAlign: 'center', marginTop: '20px' }}>
              <audio src={audioURL} controls style={{ width: '100%', marginBottom: '10px' }} />
              <button
                onClick={onNext}
                style={{
                  width: '100%',
                  padding: '15px',
                  background: '#4CAF50',
                  color: 'white',
                  border: 'none',
                  borderRadius: '10px',
                  cursor: 'pointer',
                  fontWeight: 'bold',
                }}
              >
                Next →
              </button>
            </div>
          )}
        </>
      ) : (
        <>
          <h2 style={{ textAlign: 'center', marginBottom: '20px' }}>Playback All Words</h2>
          <p style={{ textAlign: 'center', marginBottom: '20px', color: '#666' }}>
            Recorded: {words.join(', ')}
          </p>
          <input
            value={sentence}
            onChange={(e) => setSentence(e.target.value)}
            placeholder="Add a connecting sentence (optional, e.g., and then)"
            style={{
              width: '100%',
              padding: '10px',
              border: '2px solid #ddd',
              borderRadius: '10px',
              marginBottom: '10px',
              boxSizing: 'border-box',
            }}
          />
          {recordedAudio.length === words.length && (
            <div style={{ textAlign: 'center', marginTop: '20px' }}>
              <audio
                src={URL.createObjectURL(new Blob(recordedAudio, { type: 'audio/webm' }))}
                controls
                style={{ width: '100%', marginBottom: '10px' }}
              />
              <button
                onClick={onNext}
                style={{
                  width: '100%',
                  padding: '15px',
                  background: '#4CAF50',
                  color: 'white',
                  border: 'none',
                  borderRadius: '10px',
                  cursor: 'pointer',
                  fontWeight: 'bold',
                }}
              >
                Next →
              </button>
            </div>
          )}
        </>
      )}
    </div>
  );
};

export default WelcomeScreen;
```

---

### Key Changes
1. **New View: `sentence`**:
   - Added `ingView === 'sentence'` to handle the new page.
   - Transitions from `record` view after recording all words or a single word.

2. **SentencePage Component**:
   - **Pink Button Flow**: For a single word (e.g., "climbing"), provides an input for a sentence, record button, stop button, and playback.
   - **Green Button Flow**: For multiple words, displays a playback audio of all recorded words, with an optional sentence input (e.g., "and then") to connect them.

3. **Recording Logic**:
   - `RecordWord` now calls `onRecord` to store each audio blob in `recordedAudio`.
   - `SentencePage` concatenates all `recordedAudio` blobs for playback in the green button flow.

4. **Navigation**:
   - "← Back" returns to `words` for multiple words or `record` for a single word.

---

### Testing Instructions
1. **Deploy**:
   - Replace `client/src/App.tsx` in Replit and push:
     ```bash
     git add .
     git commit -m "Add Secret Sauce page for Action mode with sentence and playback"
     git push
     ```
   - Verify on your test site.

2. **Test Pink Button**:
   - Type "climbing," click "Record Typed Word(s) →," record, then on "NextSorry about that, something didn't go as planned. Please try again, and if you're still seeing this message, go ahead and restart the app.